#include "parameters.h"
#include "functions.h"
// ================================================================================================================================ //
// ======================================================== MODEL PARAMETERS ====================================================== //
// ================================================================================================================================ //
void get_epidemic_parameters(Prob *P){
// -------------------------------------------------------------------------------------------------------------------------------- //
// --------------------------------------------------------- people going places -------------------------------------------------- //
// -------------------------------------------------------------------------------------------------------------------------------- //
// --------------------------------------------------------------- no alert ------------------------------------------------------- //
	// go [0=no alert][0=S] --> h, w, hosp
	P -> go[0][0].h = 1.0;
	P -> go[0][0].w = 1.0;
	P -> go[0][0].hosp = 0.005;
	// go [0=no alert][1=E] --> h, w, hosp
	P -> go[0][1].h = 1.0;
	P -> go[0][1].w = 0.5;
	P -> go[0][1].hosp = 0.05;
	// go [0=no alert][2=I] --> h, w, hosp
	P -> go[0][2].h = 0.05;
	P -> go[0][2].w = 0.0;
	P -> go[0][2].hosp = 0.95;
	// go [0=no alert][3=R] --> h, w, hosp
	P -> go[0][3].h = 1.0;
	P -> go[0][3].w = 1.0;
	P -> go[0][3].hosp = 0.005;
	// go [0=no alert][4=D] --> h, w, hosp
	P -> go[0][4].h = 0.0;
	P -> go[0][4].w = 0.0;
	P -> go[0][4].hosp = 0.0;
// -------------------------------------------------------------- with alert ------------------------------------------------------ //
	// go [1=alert][0=S] --> h, w, hosp
	P -> go[1][0].h = 1.0;
	P -> go[1][0].w = 0.05;
	P -> go[1][0].hosp = 0.005;
	// go [1=alert][1=E] --> h, w, hosp
	P -> go[1][1].h = 1.0;
	P -> go[1][1].w = 0.025;
	P -> go[1][1].hosp = 0.05;
	// go [1=alert][2=I] --> h, w, hosp
	P -> go[1][2].h = 0.05;
	P -> go[1][2].w = 0.0;
	P -> go[1][2].hosp = 0.95;
	// go [1=alert][3=R] --> h, w, hosp
	P -> go[1][3].h = 1.0;
	P -> go[1][3].w = 0.05;
	P -> go[1][3].hosp = 0.005;
	// go [1=alert][4=D] --> h, w, hosp
	P -> go[1][4].h = 0.0;
	P -> go[1][4].w = 0.0;
	P -> go[1][4].hosp = 0.0;
// -------------------------------------------------------------------------------------------------------------------------------- //
// --------------------------------------------------------- infection probability ------------------------------------------------ //
// -------------------------------------------------------------------------------------------------------------------------------- //
	P -> infect.h = 0.1;
	P -> infect.w = 0.1;
	P -> infect.hosp = 0.1;
// -------------------------------------------------------------------------------------------------------------------------------- //
// ----------------------------------------------------------- change of state ---------------------------------------------------- //
// -------------------------------------------------------------------------------------------------------------------------------- //
// ------------------------------------------------------------ not in hosp ------------------------------------------------------- //
	// P_prog [0=S] --> [0=S, 1=E, 2=I, 3=R, 4=D]
	P -> evolve[0][0][0] = 1.0;
	P -> evolve[0][0][1] = 0.0;
	P -> evolve[0][0][2] = 0.0;
	P -> evolve[0][0][3] = 0.0;
	P -> evolve[0][0][4] = 0.0;
	// P_prog [1=E] --> [0=S, 1=E, 2=I, 3=R, 4=D]
	P -> evolve[0][1][0] = 0.0;
	P -> evolve[0][1][1] = 0.933;
	P -> evolve[0][1][2] = 0.033;
	P -> evolve[0][1][3] = 0.034;
	P -> evolve[0][1][4] = 0.0;
	// P_prog [2=I] --> [0=S, 1=E, 2=I, 3=R, 4=D]
	P -> evolve[0][2][0] = 0.0;
	P -> evolve[0][2][1] = 0.0;
	P -> evolve[0][2][2] = 0.933;
	P -> evolve[0][2][3] = 0.033;
	P -> evolve[0][2][4] = 0.034;
	// P_prog [3=R] --> [0=S, 1=E, 2=I, 3=R, 4=D]
	P -> evolve[0][3][0] = 0.0;
	P -> evolve[0][3][1] = 0.0;
	P -> evolve[0][3][2] = 0.0;
	P -> evolve[0][3][3] = 1.0;
	P -> evolve[0][3][4] = 0.0;
	// P_prog [4=D] --> [0=S, 1=E, 2=I, 3=R, 4=D]
	P -> evolve[0][4][0] = 0.0;
	P -> evolve[0][4][1] = 0.0;
	P -> evolve[0][4][2] = 0.0;
	P -> evolve[0][4][3] = 0.0;
	P -> evolve[0][4][4] = 1.0;
	
	for(int64_t i = 0; i < N_states; i++)
    {
		P -> evolve_cumulative[0][i][0] = P -> evolve[0][i][0];
		for(int64_t j = 1; j < N_states; j++)
		{
			P -> evolve_cumulative[0][i][j] = P -> evolve_cumulative[0][i][j-1] + P -> evolve[0][i][j];
		}
	}
// ---------------------------------------------------------- in hosp not collapsed ----------------------------------------------------- //

	P -> evolve[1][0][0] = 1.0;
	P -> evolve[1][0][1] = 0.0;
	P -> evolve[1][0][2] = 0.0;
	P -> evolve[1][0][3] = 0.0;
	P -> evolve[1][0][4] = 0.0;
	
	P -> evolve[1][1][0] = 0.0;
	P -> evolve[1][1][1] = 0.933;
	P -> evolve[1][1][2] = 0.033;
	P -> evolve[1][1][3] = 0.034;
	P -> evolve[1][1][4] = 0.0;
	
	P -> evolve[1][2][0] = 0.0;
	P -> evolve[1][2][1] = 0.0;
	P -> evolve[1][2][2] = 0.93;
	P -> evolve[1][2][3] = 0.06;
	P -> evolve[1][2][4] = 0.01;
	
	P -> evolve[1][3][0] = 0.0;
	P -> evolve[1][3][1] = 0.0;
	P -> evolve[1][3][2] = 0.0;
	P -> evolve[1][3][3] = 1.0;
	P -> evolve[1][3][4] = 0.0;
	
	P -> evolve[1][4][0] = 0.0;
	P -> evolve[1][4][1] = 0.0;
	P -> evolve[1][4][2] = 0.0;
	P -> evolve[1][4][3] = 0.0;
	P -> evolve[1][4][4] = 1.0;

	for(int64_t i = 0; i < N_states; i++)
    {
		P -> evolve_cumulative[1][i][0] = P -> evolve[1][i][0];
		for(int64_t j = 1; j < N_states; j++)
		{
			P -> evolve_cumulative[1][i][j] = P -> evolve_cumulative[1][i][j-1] + P -> evolve[1][i][j];
		}
	}

// ------------------------------------------------------------ in hosp collapsed ------------------------------------------------------- //
	P -> evolve[2][0][0] = 1.0;
	P -> evolve[2][0][1] = 0.0;
	P -> evolve[2][0][2] = 0.0;
	P -> evolve[2][0][3] = 0.0;
	P -> evolve[2][0][4] = 0.0;
	
	P -> evolve[2][1][0] = 0.0;
	P -> evolve[2][1][1] = 0.933;
	P -> evolve[2][1][2] = 0.033;
	P -> evolve[2][1][3] = 0.034;
	P -> evolve[2][1][4] = 0.0;
	
	P -> evolve[2][2][0] = 0.0;
	P -> evolve[2][2][1] = 0.0;
	P -> evolve[2][2][2] = 0.933;
	P -> evolve[2][2][3] = 0.033;
	P -> evolve[2][2][4] = 0.034;
	
	P -> evolve[2][3][0] = 0.0;
	P -> evolve[2][3][1] = 0.0;
	P -> evolve[2][3][2] = 0.0;
	P -> evolve[2][3][3] = 1.0;
	P -> evolve[2][3][4] = 0.0;
	
	P -> evolve[2][4][0] = 0.0;
	P -> evolve[2][4][1] = 0.0;
	P -> evolve[2][4][2] = 0.0;
	P -> evolve[2][4][3] = 0.0;
	P -> evolve[2][4][4] = 1.0;

	for(int64_t i = 0; i < N_states; i++)
    {
		P -> evolve_cumulative[2][i][0] = P -> evolve[2][i][0];
		for(int64_t j = 1; j < N_states; j++)
		{
			P -> evolve_cumulative[2][i][j] = P -> evolve_cumulative[2][i][j-1] + P -> evolve[2][i][j];
		}
	}
	
}
	
